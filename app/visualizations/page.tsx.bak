"use client"

import React, { useState, useEffect, useMemo } from "react"
import { useEmojiData } from "@/lib/hooks/use-emoji-data"
import { Card, CardContent, CardDescription, CardHeader, CardTitle, CardFooter } from "@/components/ui/card"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle } from "@/components/ui/dialog"
import { ScrollArea } from "@/components/ui/scroll-area"
import Image from "next/image"
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, ResponsiveContainer, PieChart, Pie, Cell, LineChart, Line, AreaChart, Area, ScatterChart, Scatter, ZAxis, Radar, RadarChart, PolarGrid, PolarAngleAxis, PolarRadiusAxis, LabelList } from "recharts"
import { format, subDays, differenceInDays, startOfMonth, endOfMonth, eachDayOfInterval, isWithinInterval, parseISO } from "date-fns"
import { ChartPieIcon, BarChart3Icon, LineChartIcon, Activity, TrendingUp } from "lucide-react"
import dynamic from "next/dynamic"

// Import client-only chart components
import { ClientOnly, DynamicTooltip as RechartsTooltip, DynamicLegend as RechartsLegend } from "@/app/visualizations/recharts-wrapper"

// Dynamic imports for UI components
const ChartContainer = dynamic(() => import("@/components/ui/chart").then(mod => mod.ChartContainer), { ssr: false })
const ChartTooltip = dynamic(() => import("@/components/ui/chart").then(mod => mod.ChartTooltip), { ssr: false })
const ChartTooltipContent = dynamic(() => import("@/components/ui/chart").then(mod => mod.ChartTooltipContent), { ssr: false })
const ChartLegend = dynamic(() => import("@/components/ui/chart").then(mod => mod.ChartLegend), { ssr: false })

const EmojiOverlay = dynamic(() => import("@/components/emoji-overlay"), { ssr: false })

export default function VisualizationsPage() {
  // Add client-side only rendering to avoid hydration mismatches
  const [isClient, setIsClient] = useState(false)
  const [activeEmojiType, setActiveEmojiType] = useState<"image" | "gif">("image")
  const [selectedNameLength, setSelectedNameLength] = useState<number | null>(null)
  const [emojisWithLength, setEmojisWithLength] = useState<any[]>([])
  const [showEmojiDialog, setShowEmojiDialog] = useState(false)
  const [selectedEmoji, setSelectedEmoji] = useState<any>(null)
  const [selectedWord, setSelectedWord] = useState<string | null>(null)
  const [emojisWithWord, setEmojisWithWord] = useState<any[]>([])
  const [showWordEmojiDialog, setShowWordEmojiDialog] = useState(false)
  
  useEffect(() => {
    setIsClient(true)
  }, [])

  const { emojiData, loading } = useEmojiData()
  
  // Function to handle click on name length bar
  const handleNameLengthClick = (data: any) => {
    if (!emojiData) return
    
    const length = data.length
    const matchingEmojis = emojiData.filter(emoji => 
      !emoji.is_alias && emoji.name && emoji.name.length === length
    ).sort((a, b) => (b.created || 0) - (a.created || 0)) // Sort by newest first
    
    setSelectedNameLength(length)
    setEmojisWithLength(matchingEmojis)
    setShowEmojiDialog(true)
  }
  
  // Function to handle click on an individual emoji
  const handleEmojiClick = (emoji: any) => {
    // Close any open dialogs first
    setShowEmojiDialog(false)
    setShowWordEmojiDialog(false)
    // Set a small timeout to ensure dialogs are closed before opening the overlay
    setTimeout(() => {
      setSelectedEmoji(emoji)
    }, 50)
  }
  
  // Function to close the emoji overlay
  const handleCloseEmojiOverlay = () => {
    setSelectedEmoji(null)
  }
  
  // Function to handle click on word bar
  const handleWordClick = (data: any) => {
    if (!emojiData) return
    
    const word = data.word
    const matchingEmojis = emojiData.filter(emoji => 
      !emoji.is_alias && emoji.name && emoji.name.toLowerCase().includes(word.toLowerCase())
    ).sort((a, b) => (b.created || 0) - (a.created || 0)) // Sort by newest first
    
    setSelectedWord(word)
    setEmojisWithWord(matchingEmojis)
    setShowWordEmojiDialog(true)
  }
  
  // Calculate the current time in seconds (same format as emoji.created)
  const currentTime = Math.floor(Date.now() / 1000)
  
  // Prepare data for charts
  const chartData = useMemo(() => {
    if (!emojiData || emojiData.length === 0) return {
      topCreators: [],
      emojisByMonth: [],
      topCategories: [],
      creationTimeline: [],
      recentActivity: [],
      userEngagement: [],
      emojiDistribution: [],
      aliasRatio: { original: 0, alias: 0 },
      weekdayDistribution: [],
      emojiTypes: [],
      commonWords: []
    }

    // Top emoji creators
    const creators: Record<string, number> = {}
    emojiData.forEach(emoji => {
      if (emoji.user_display_name && !emoji.is_alias) {
        creators[emoji.user_display_name] = (creators[emoji.user_display_name] || 0) + 1
      }
    })
    
    const topCreators = Object.entries(creators)
      .map(([name, count]) => ({ name: name.split(' ')[0], count }))
      .sort((a, b) => (b.count as number) - (a.count as number))
      .slice(0, 10)

    // Emojis by month
    const monthlyData: Record<string, number> = {}
    emojiData.forEach(emoji => {
      if (emoji.created && !emoji.is_alias) {
        const date = new Date(emoji.created * 1000)
        const monthYear = format(date, 'MMM yyyy')
        monthlyData[monthYear] = (monthlyData[monthYear] || 0) + 1
      }
    })
    
    const emojisByMonth = Object.entries(monthlyData)
      .map(([month, count]) => ({ month, count }))
      .sort((a, b) => {
        const dateA = new Date(a.month)
        const dateB = new Date(b.month)
        return dateA.getTime() - dateB.getTime()
      })
      .slice(-12) // Last 12 months

    // Emoji categories (based on first character for demo purposes)
    const categories: Record<string, number> = {}
    emojiData.forEach(emoji => {
      if (!emoji.is_alias) {
        const firstChar = emoji.name.charAt(0).toLowerCase()
        categories[firstChar] = (categories[firstChar] || 0) + 1
      }
    })
    
    const topCategories = Object.entries(categories)
      .map(([category, count]) => ({ category, count }))
      .sort((a, b) => (b.count as number) - (a.count as number))
      .slice(0, 8)

    // Creation timeline (last 30 days)
    const last30Days = Array.from({ length: 30 }, (_, i) => {
      const date = subDays(new Date(), 29 - i)
      return {
        date: format(date, 'MMM dd'),
        count: 0,
        timestamp: date.getTime() / 1000
      }
    })
    
    emojiData.forEach(emoji => {
      if (emoji.created && !emoji.is_alias) {
        const index = last30Days.findIndex(day => {
          const dayStart = new Date(day.timestamp * 1000)
          dayStart.setHours(0, 0, 0, 0)
          const dayEnd = new Date(day.timestamp * 1000)
          dayEnd.setHours(23, 59, 59, 999)
          
          return emoji.created >= dayStart.getTime() / 1000 && 
                 emoji.created <= dayEnd.getTime() / 1000
        })
        
        if (index !== -1) {
          last30Days[index].count++
        }
      }
    })
    
    // Recent activity (emojis created in the last 90 days)
    const ninetyDaysAgo = currentTime - (90 * 24 * 60 * 60)
    const recentEmojis = emojiData
      .filter(emoji => emoji.created && emoji.created > ninetyDaysAgo && !emoji.is_alias)
      .sort((a, b) => (b.created || 0) - (a.created || 0))
    
    const recentActivity = recentEmojis.map(emoji => ({
      name: emoji.name,
      value: currentTime - (emoji.created || 0), // Time since creation in seconds
      creator: emoji.user_display_name?.split(' ')[0] || 'Unknown'
    })).slice(0, 50) // Top 50 recent emojis

    // User engagement scatter plot
    interface UserActivityData {
      name: string;
      emojis: number;
      firstCreated: number;
      lastCreated: number;
    }
    
    const userActivity: Record<string, UserActivityData> = {}
    emojiData.forEach(emoji => {
      if (emoji.user_display_name && emoji.created && !emoji.is_alias) {
        if (!userActivity[emoji.user_display_name]) {
          userActivity[emoji.user_display_name] = {
            name: emoji.user_display_name.split(' ')[0],
            emojis: 0,
            firstCreated: emoji.created,
            lastCreated: emoji.created
          }
        }
        
        userActivity[emoji.user_display_name].emojis++
        userActivity[emoji.user_display_name].firstCreated = Math.min(
          userActivity[emoji.user_display_name].firstCreated,
          emoji.created || Infinity
        )
        userActivity[emoji.user_display_name].lastCreated = Math.max(
          userActivity[emoji.user_display_name].lastCreated,
          emoji.created || 0
        )
      }
    })
    
    const userEngagement = Object.values(userActivity)
      .map((user: UserActivityData) => ({
        name: user.name,
        emojis: user.emojis,
        timespan: user.lastCreated - user.firstCreated, // Time between first and last emoji
        activity: user.emojis / ((user.lastCreated - user.firstCreated) / (60 * 60 * 24) + 1) // Emojis per day
      }))
      .filter(user => user.emojis > 1) // Only users with more than 1 emoji

    // Emoji name length distribution
    const nameLengths: Record<number, number> = {}
    emojiData.forEach(emoji => {
      if (!emoji.is_alias && emoji.name) {
        const length = emoji.name.length
        nameLengths[length] = (nameLengths[length] || 0) + 1
      }
    })
    
    const emojiDistribution = Object.entries(nameLengths)
      .map(([length, count]) => ({ length: Number(length), count }))
      .sort((a, b) => a.length - b.length)

    // Original vs Alias ratio
    const originalCount = emojiData.filter(emoji => !emoji.is_alias).length
    const aliasCount = emojiData.filter(emoji => emoji.is_alias).length
    
    const aliasRatio = {
      original: originalCount,
      alias: aliasCount
    }

    // Weekday distribution
    const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
    const weekdayCounts = Array(7).fill(0)
    
    emojiData.forEach(emoji => {
      if (emoji.created && !emoji.is_alias) {
        const date = new Date(emoji.created * 1000)
        const weekday = date.getDay() // 0 = Sunday, 6 = Saturday
        weekdayCounts[weekday]++
      }
    })
    
    const weekdayDistribution = weekdays.map((day, index) => ({
      day,
      count: weekdayCounts[index]
    }))

    // Emoji types (image vs GIF)
    const emojiTypes = [];
    const now = new Date();
    // Generate data for the last 90 days
    for (let i = 89; i >= 0; i--) {
      const date = new Date(now);
      date.setDate(date.getDate() - i);
      const dateString = format(date, 'yyyy-MM-dd');
      
      // Count image and GIF emojis for this date
      const dayStart = new Date(date);
      dayStart.setHours(0, 0, 0, 0);
      const dayEnd = new Date(date);
      dayEnd.setHours(23, 59, 59, 999);
      
      const dayStartTimestamp = dayStart.getTime() / 1000;
      const dayEndTimestamp = dayEnd.getTime() / 1000;
      
      // Filter emojis created on this day
      const dayEmojis = emojiData.filter(emoji => 
        emoji.created && 
        emoji.created >= dayStartTimestamp && 
        emoji.created <= dayEndTimestamp &&
        !emoji.is_alias
      );
      
      // Count image and GIF emojis
      const imageEmojis = dayEmojis.filter(emoji => 
        emoji.url && !emoji.url.toLowerCase().includes('.gif')
      ).length;
      
      const gifEmojis = dayEmojis.filter(emoji => 
        emoji.url && emoji.url.toLowerCase().includes('.gif')
      ).length;
      
      emojiTypes.push({
        date: dateString,
        image: imageEmojis,
        gif: gifEmojis
      });
    }
    
    // Analyze common words in emoji names
    const wordCounts: Record<string, number> = {};
    const stopWords = ['the', 'and', 'a', 'an', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are'];

    emojiData.forEach(emoji => {
      if (!emoji.is_alias && emoji.name) {
        // Split emoji name by non-alphanumeric characters and underscores
        const words = emoji.name.toLowerCase().split(/[^a-z0-9]+/)
          .filter(word => word.length > 2) // Only words with 3+ characters
          .filter(word => !stopWords.includes(word)); // Filter out stop words
        
        words.forEach(word => {
          wordCounts[word] = (wordCounts[word] || 0) + 1;
        });
      }
    });
    
    // Get top words
    const commonWords = Object.entries(wordCounts)
      .map(([word, count]) => ({ word, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 8); // Top 8 words
      
    // Calculate emoji creation by time of day in 3-hour buckets
    const timeLabels = [
      "12-3 AM",
      "3-6 AM",
      "6-9 AM",
      "9-12 PM",
      "12-3 PM",
      "3-6 PM",
      "6-9 PM",
      "9-12 AM"
    ];
    
    // Initialize counts for each time bucket
    const timeBucketCounts = Array(8).fill(0);
    
    emojiData.forEach(emoji => {
      if (!emoji.is_alias && emoji.created) {
        const date = new Date(emoji.created * 1000);
        const hour = date.getHours();
        // Map hour to bucket index (0-7)
        const bucketIndex = Math.floor(hour / 3);
        timeBucketCounts[bucketIndex]++;
      }
    });
    
    // Create the final data structure for the chart
    const emojisByHour = timeLabels.map((label, index) => ({
      timeOfDay: label,
      count: timeBucketCounts[index]
    }));
    
    // Find the peak time period outside of the render function to avoid hydration issues
    const peakTimePeriod = [...emojisByHour].sort((a, b) => b.count - a.count)[0]?.timeOfDay || "Unknown";
    
    return {
      topCreators,
      emojisByMonth,
      topCategories,
      creationTimeline: last30Days,
      recentActivity,
      userEngagement,
      emojiDistribution,
      aliasRatio,
      weekdayDistribution,
      emojiTypes,
      commonWords,
      emojisByHour,
      peakTimePeriod
    }
  }, [emojiData, currentTime])

// Emoji name length distribution
const nameLengths: Record<number, number> = {}
emojiData.forEach(emoji => {
  if (!emoji.is_alias && emoji.name) {
    const length = emoji.name.length
    nameLengths[length] = (nameLengths[length] || 0) + 1
  }
})

const emojiDistribution = Object.entries(nameLengths)
  .map(([length, count]) => ({ length: Number(length), count }))
  .sort((a, b) => a.length - b.length)

// Original vs Alias ratio
const originalCount = emojiData.filter(emoji => !emoji.is_alias).length
const aliasCount = emojiData.filter(emoji => emoji.is_alias).length

const aliasRatio = {
  original: originalCount,
  alias: aliasCount
}

// Weekday distribution
const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
const weekdayCounts = Array(7).fill(0)

emojiData.forEach(emoji => {
  if (emoji.created && !emoji.is_alias) {
    const date = new Date(emoji.created * 1000)
    const weekday = date.getDay() // 0 = Sunday, 6 = Saturday
    weekdayCounts[weekday]++
  }
})

const weekdayDistribution = weekdays.map((day, index) => ({
  day,
  count: weekdayCounts[index]
}))

// Emoji types (image vs GIF)
const emojiTypes = [];
const now = new Date();
// Generate data for the last 90 days
for (let i = 89; i >= 0; i--) {
  const date = new Date(now);
  date.setDate(date.getDate() - i);
  const dateString = format(date, 'yyyy-MM-dd');
  
  // Count image and GIF emojis for this date
  const dayStart = new Date(date);
  dayStart.setHours(0, 0, 0, 0);
  const dayEnd = new Date(date);
  dayEnd.setHours(23, 59, 59, 999);
  
  const dayStartTimestamp = dayStart.getTime() / 1000;
  const dayEndTimestamp = dayEnd.getTime() / 1000;
  
  // Filter emojis created on this day
  const dayEmojis = emojiData.filter(emoji => 
    emoji.created && 
    emoji.created >= dayStartTimestamp && 
    emoji.created <= dayEndTimestamp &&
    !emoji.is_alias
  );
  
  // Count image and GIF emojis
  const imageEmojis = dayEmojis.filter(emoji => 
    emoji.url && !emoji.url.toLowerCase().includes('.gif')
  ).length;
  
  const gifEmojis = dayEmojis.filter(emoji => 
    emoji.url && emoji.url.toLowerCase().includes('.gif')
  ).length;
  
  emojiTypes.push({
    date: dateString,
    image: imageEmojis,
    gif: gifEmojis
  });
}

// Analyze common words in emoji names
const wordCounts: Record<string, number> = {};
const stopWords = ['the', 'and', 'a', 'an', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are'];

emojiData.forEach(emoji => {
  if (!emoji.is_alias && emoji.name) {
    // Split emoji name by non-alphanumeric characters and underscores
    const words = emoji.name.toLowerCase().split(/[^a-z0-9]+/)
      .filter(word => word.length > 2) // Only words with 3+ characters
      .filter(word => !stopWords.includes(word)); // Filter out stop words
    
    words.forEach(word => {
      wordCounts[word] = (wordCounts[word] || 0) + 1;
    });
  }
});

// Get top words
const commonWords = Object.entries(wordCounts)
  .map(([word, count]) => ({ word, count }))
  .sort((a, b) => b.count - a.count)
  .slice(0, 8); // Top 8 words

// Calculate emoji creation by time of day in 3-hour buckets
const timeLabels = [
  "12-3 AM",
  "3-6 AM",
  "6-9 AM",
  "9-12 PM",
  "12-3 PM",
  "3-6 PM",
  "6-9 PM",
  "9-12 AM"
];

// Initialize counts for each time bucket
const timeBucketCounts = Array(8).fill(0);

emojiData.forEach(emoji => {
  if (!emoji.is_alias && emoji.created) {
    const date = new Date(emoji.created * 1000);
    const hour = date.getHours();
    // Map hour to bucket index (0-7)
    const bucketIndex = Math.floor(hour / 3);
    timeBucketCounts[bucketIndex]++;
  }
});

// Create the final data structure for the chart
const emojisByHour = timeLabels.map((label, index) => ({
  timeOfDay: label,
  count: timeBucketCounts[index]
}));

// Find the peak time period outside of the render function to avoid hydration issues
const peakTimePeriod = [...emojisByHour].sort((a, b) => b.count - a.count)[0]?.timeOfDay || "Unknown";

// Colors for charts - using vibrant colors that match the screenshot
const COLORS = ['#FF4560', '#00E396', '#FEB019', '#008FFB', '#775DD0', '#2E93FA', '#F9A3A4', '#26C6DA', '#64C2A6', '#AECB4F', '#EE6868', '#A86CE4']

// Only render when client-side to avoid hydration mismatches
return (
  <>
    {!isClient ? (
      <div className="flex flex-col items-center justify-center min-h-[400px]">
        <span className="text-muted-foreground">Loading charts…</span>
      </div>
    ) : (
      <>

        {/* Top Emoji Creation Days - Wide card */}
        <Card className="md:col-span-2">
          <CardHeader>
            <CardTitle>Top Emoji Creation Days</CardTitle>
            <CardDescription>Days with the highest emoji creation activity</CardDescription>
          </CardHeader>
          <CardContent>
            <ChartContainer
              className="h-[300px] w-full"
              config={{
                count: {
                  label: "Emojis Created",
                  color: "#4169E1"
                },
                label: {
                  color: "hsl(var(--background))"
                }
              }}
            >
              <BarChart
                accessibilityLayer
                data={chartData.creationTimeline.sort((a, b) => b.count - a.count).slice(0, 10)}
                layout="vertical"
                margin={{
                  right: 16,
                }}
              >
                <CartesianGrid horizontal={false} />
                <YAxis
                  dataKey="date"
                  type="category"
                  tickLine={false}
                  tickMargin={10}
                  axisLine={false}
                  hide
                />
                <XAxis dataKey="count" type="number" hide />
                <ClientOnly><RechartsTooltip
                  cursor={false}
                  content={({ active, payload }) => {
                    if (active && payload && payload.length) {
                      return (
                        <ChartTooltipContent>
                          <div className="font-semibold">{payload[0].payload.date}</div>
                          <div className="text-xs text-muted-foreground">
                            {payload[0].value} emojis
                          </div>
                        </ChartTooltipContent>
                      )
                <CardTitle>Top Emoji Creation Days</CardTitle>
                <CardDescription>Days with the highest emoji creation activity</CardDescription>
              </CardHeader>
              <CardContent>
                <ChartContainer
                  className="h-[300px] w-full"
                  config={{
                    count: {
                      label: "Emojis Created",
                      color: "#4169E1"
                    },
                    label: {
                      color: "hsl(var(--background))"
                    }
                  }}
                >
                  <BarChart
                    accessibilityLayer
                    data={chartData.creationTimeline.sort((a, b) => b.count - a.count).slice(0, 10)}
                    layout="vertical"
                    margin={{
                      right: 16,
                    }}
                  >
                    <CartesianGrid horizontal={false} />
                    <YAxis
                      dataKey="date"
                      type="category"
                      tickLine={false}
                      tickMargin={10}
                      axisLine={false}
                      hide
                    />
                    <XAxis dataKey="count" type="number" hide />
                    <ClientOnly><RechartsTooltip
                      cursor={false}
                      content={({ active, payload }) => {
                        if (active && payload && payload.length) {
                          return (
                            <ChartTooltipContent>
                              <div className="font-semibold">{payload[0].payload.date}</div>
                              <div className="text-xs text-muted-foreground">
                                {payload[0].value} emojis
                              </div>
                            </ChartTooltipContent>
                          )
                        }
                        return null
                      }}
                    /></ClientOnly>
                    <Bar
                      dataKey="count"
                      layout="vertical"
                      fill="#4169E1"
                      radius={4}
                    >
                      <LabelList
                        dataKey="date"
                        position="insideLeft"
                        offset={8}
                        className="fill-[--color-label]"
                        fontSize={12}
                      />
                      <LabelList
                        dataKey="count"
                        position="right"
                        offset={8}
                        className="fill-foreground"
                        fontSize={12}
                      />
                    </Bar>
                  </BarChart>
                </ChartContainer>
              </CardContent>
              <CardFooter className="flex-col items-start gap-2 text-sm">
                <div className="flex gap-2 font-medium leading-none">
                  Peak day: {chartData.creationTimeline.sort((a, b) => b.count - a.count)[0]?.date}
                  <TrendingUp className="h-4 w-4" />
                </div>
                <div className="leading-none text-muted-foreground">
                  Showing days with the highest emoji creation activity
                </div>
              </CardFooter>
            </Card>

            {/* Monthly Trend */}
            <Card>
              <CardHeader>
                <CardTitle>Monthly Emoji Creation</CardTitle>
                <CardDescription>Trend of emoji creation over time</CardDescription>
              </CardHeader>
              <CardContent>
                <ChartContainer
                  className="aspect-[4/3]"
                  config={{
                    count: {
                      label: "Emojis Created",
                      theme: {
                        light: "#8884d8",
                        dark: "#8884d8"
                      }
                    }
                  }}
                >
                  <LineChart
                    data={chartData.emojisByMonth}
                    margin={{ top: 5, right: 30, left: 20, bottom: 5 }}
                  >
                    <CartesianGrid strokeDasharray="3 3" horizontal vertical={false} />
                    <XAxis 
                      dataKey="month" 
                      tickLine={false}
                      axisLine={false}
                    />
                    <YAxis 
                      tickLine={false}
                      axisLine={false}
                    />
                    <ClientOnly><RechartsTooltip
                      content={({ active, payload }) => {
                        if (active && payload && payload.length) {
                          return (
                            <ChartTooltipContent>
                              <div className="font-semibold">{payload[0].payload.month}</div>
                              <div className="text-xs text-muted-foreground">
                                {payload[0].value} emojis
                              </div>
                            </ChartTooltipContent>
                          )
                        }
                        return null
                      }}
                    /></ClientOnly>
                    <ClientOnly><RechartsLegend /></ClientOnly>
                    <Line 
                      type="monotone" 
                      dataKey="count" 
                      strokeWidth={2}
                      activeDot={{ r: 6, strokeWidth: 0, fill: "#008FFB" }}
                      dot={{ strokeWidth: 0, fill: "#008FFB" }}
                      stroke="#008FFB" 
                    />
                  </LineChart>
                </ChartContainer>
              </CardContent>
            </Card>



            {/* Emojis by Day of Week */}
            <Card className="md:col-span-1">
              <CardHeader>
                <CardTitle>Emojis by Day of Week</CardTitle>
                <CardDescription>When emojis are typically created</CardDescription>
              </CardHeader>
              <CardContent>
                <ChartContainer
                  config={{
                    count: {
                      label: "Emojis Created",
                      color: "#008FFB"
                    },
                    label: {
                      color: "hsl(var(--background))"
                    }
                  }}
                  className="w-full h-auto aspect-[3/2]"
                >
                  <BarChart
                    accessibilityLayer
                    data={chartData.weekdayDistribution}
                    layout="vertical"
                    margin={{
                      top: 0,
                      right: 16,
                      bottom: 0,
                      left: 0
                    }}
                  >
                    <CartesianGrid horizontal={false} />
                    <YAxis
                      dataKey="day"
                      type="category"
                      tickLine={false}
                      tickMargin={10}
                      axisLine={false}
                      hide
                    />
                    <XAxis dataKey="count" type="number" hide />
                    <ClientOnly><RechartsTooltip
                      cursor={false}
                      content={({ active, payload }) => {
                        if (active && payload && payload.length) {
                          return (
                            <ChartTooltipContent>
                              <div className="font-semibold">{payload[0].payload.day}</div>
                              <div className="text-xs text-muted-foreground">
                                {payload[0].value} emojis
                              </div>
                            </ChartTooltipContent>
                          )
                        }
                        return null
                      }}
                    /></ClientOnly>
                    <Bar
                      dataKey="count"
                      layout="vertical"
                      fill="#008FFB"
                      radius={4}
                    >
                      <LabelList
                        dataKey="day"
                        position="insideLeft"
                        offset={8}
                        className="fill-[--color-label]"
                        fontSize={12}
                      />
                      <LabelList
                        dataKey="count"
                        position="right"
                        offset={8}
                        className="fill-foreground"
                        fontSize={12}
                      />
                    </Bar>
                  </BarChart>
                </ChartContainer>
              </CardContent>
              <CardFooter className="flex-col items-start gap-2 text-sm">
                <div className="flex gap-2 font-medium leading-none">
                  Most active day: {chartData.weekdayDistribution.sort((a, b) => b.count - a.count)[0]?.day}
                  <TrendingUp className="h-4 w-4" />
                </div>
                <div className="leading-none text-muted-foreground">
                  Showing total emoji creation by day of the week
                </div>
              </CardFooter>
            </Card>



            {/* Emoji Name Length Distribution */}
            <Card className="md:col-span-2">
              <CardHeader>
                <CardTitle>Name Length Distribution</CardTitle>
                <CardDescription>Emoji name character count</CardDescription>
              </CardHeader>
              <CardContent>
                <ChartContainer
                  className="w-full aspect-[2/1]"
                  config={{
                    count: {
                      label: "Emojis",
                      theme: {
                        light: "#82ca9d",
                        dark: "#82ca9d"
                      }
                    }
                  }}
                >
                  <BarChart
                    data={chartData.emojiDistribution}
                    margin={{ top: 5, right: 30, left: 20, bottom: 5 }}
                  >
                    <CartesianGrid strokeDasharray="3 3" horizontal vertical={false} />
                    <XAxis 
                      dataKey="length" 
                      tickLine={false}
                      axisLine={false}
                    />
                    <YAxis 
                      tickLine={false}
                      axisLine={false}
                    />
                    <ClientOnly><RechartsTooltip
                      content={({ active, payload }) => {
                        if (active && payload && payload.length) {
                          return (
                            <ChartTooltipContent>
                              <div className="font-semibold">{payload[0].payload.length} characters</div>
                              <div className="text-xs text-muted-foreground">
                                {payload[0].value} emojis
                              </div>
                            </ChartTooltipContent>
                          )
                        }
                        return null
                      }}
                    /></ClientOnly>
                    <ClientOnly><RechartsLegend /></ClientOnly>
                    <Bar 
                      dataKey="count" 
                      fill="#00E396" 
                      radius={[4, 4, 0, 0]}
                      onClick={handleNameLengthClick}
                      cursor="pointer"
                    />
                  </BarChart>
                </ChartContainer>
              </CardContent>
            </Card>

            {/* Image vs GIF Emojis - Interactive Chart */}
            <Card className="lg:col-span-2">
              <CardHeader className="flex flex-col items-stretch space-y-0 border-b p-0 sm:flex-row">
                <div className="flex flex-1 flex-col justify-center gap-1 px-6 py-5 sm:py-6">
                  <CardTitle>Image vs GIF Emojis</CardTitle>
                  <CardDescription>
                    Breakdown of emoji types over the last 90 days
                  </CardDescription>
                </div>
                <div className="flex">
                  {["image", "gif"].map((key) => {
                    const total = chartData.emojiTypes.reduce((acc, curr) => acc + curr[key as "image" | "gif"], 0);
                    const isActive = activeEmojiType === key;
                    return (
                      <button
                        key={key}
                        data-active={isActive}
                        className="relative z-30 flex flex-1 flex-col justify-center gap-1 border-t px-6 py-4 text-left even:border-l data-[active=true]:bg-muted/50 sm:border-l sm:border-t-0 sm:px-8 sm:py-6"
                        onClick={() => setActiveEmojiType(key as "image" | "gif")}
                      >
                        <span className="text-xs text-muted-foreground">
                          {key === "image" ? "Static Images" : "Animated GIFs"}
                        </span>
                        <span className="text-lg font-bold leading-none sm:text-3xl">
                          {total.toLocaleString()}
                        </span>
                      </button>
                    )
                  })}
                </div>
              </CardHeader>
              <CardContent className="px-2 sm:p-6">
                <ChartContainer
                  config={{
                    views: {
                      label: "Emoji Count",
                    },
                    image: {
                      label: "Static Images",
                      color: "#00E396",
                    },
                    gif: {
                      label: "Animated GIFs",
                      color: "#FF4560",
                    },
                  }}
                  className="aspect-auto h-[250px] w-full"
                >
                  <BarChart
                    accessibilityLayer
                    data={chartData.emojiTypes}
                    margin={{
                      left: 12,
                      right: 12,
                    }}
                  >
                    <CartesianGrid vertical={false} />
                    <XAxis
                      dataKey="date"
                      tickLine={false}
                      axisLine={false}
                      tickMargin={8}
                      minTickGap={32}
                      tickFormatter={(value) => {
                        const date = new Date(value)
                        return date.toLocaleDateString("en-US", {
                          month: "short",
                          day: "numeric",
                        })
                      }}
                    />
                    <ClientOnly><RechartsTooltip
                      content={({ active, payload }) => {
                        if (active && payload && payload.length) {
                          const date = new Date(payload[0].payload.date);
                          return (
                            <ChartTooltipContent>
                              <div className="font-semibold">
                                {date.toLocaleDateString("en-US", {
                                  month: "short",
                                  day: "numeric",
                                  year: "numeric",
                                })}
                              </div>
                              <div className="text-xs text-muted-foreground">
                                {payload[0].value} {activeEmojiType === "image" ? "static images" : "animated GIFs"}
                              </div>
                            </ChartTooltipContent>
                          )
                        }
                        return null
                      }}
                    /></ClientOnly>
                    <Bar dataKey={activeEmojiType} fill={activeEmojiType === "image" ? "#00E396" : "#FF4560"} radius={4} />
                  </BarChart>
                </ChartContainer>
              </CardContent>
            </Card>

            {/* Original vs Alias */}
            <Card>
              <CardHeader className="items-center pb-4">
                <CardTitle>Emoji Creation by Hour</CardTitle>
                <CardDescription>
                  When emojis are created
                </CardDescription>
              </CardHeader>
              <CardContent className="pb-0">
                {isClient && (
                  <ChartContainer
                    config={{
                      count: {
                        label: "Emojis Created",
                        color: "#8b5cf6"
                      }
                    }}
                    className="mx-auto aspect-square max-h-[200px]"
                  >
                    <RadarChart 
                      data={chartData.emojisByHour}
                      outerRadius={70}
                    >
                      <ClientOnly><RechartsTooltip cursor={false} content={(props: any) => <ChartTooltipContent {...props} />} /></ClientOnly>
                      <PolarAngleAxis 
                        dataKey="timeOfDay" 
                        tick={{ fill: '#a1a1aa' }} 
                        axisLine={{ stroke: '#3f3f46' }}
                      />
                      <PolarGrid 
                        stroke="#3f3f46" 
                        strokeDasharray="3 3" 
                      />
                      <Radar
                        name="Emojis Created"
                        dataKey="count"
                        fill="#8b5cf6"
                        stroke="#8b5cf6"
                        fillOpacity={0.6}
                      />
                    </RadarChart>
                  </ChartContainer>
                )}
                {!isClient && (
                  <div className="flex items-center justify-center h-[200px]">
                    <p className="text-muted-foreground">Loading chart...</p>
                  </div>
                )}
              </CardContent>
              <CardFooter className="flex-col gap-2 text-sm">
                <div className="flex items-center gap-2 font-medium leading-none">
                  Peak: {chartData.peakTimePeriod}
                  <TrendingUp className="h-4 w-4" />
                </div>
                <div className="flex items-center gap-2 leading-none text-muted-foreground">
                  3-hour time blocks
                </div>
              </CardFooter>
            </Card>

            {/* Common Words Chart */}
            <Card className="md:col-span-1">
              <CardHeader>
                <CardTitle>Common Words in Emoji Names</CardTitle>
                <CardDescription>Most frequently used words in emoji names</CardDescription>
              </CardHeader>
              <CardContent>
                <ChartContainer
                  config={{
                    count: {
                      label: "Occurrences",
                    },
                    ...chartData.commonWords.reduce((acc: Record<string, any>, item, index) => {
                      acc[item.word] = {
                        label: item.word,
                        color: `hsl(var(--chart-${(index % 8) + 1}))`
                      };
                      return acc;
                    }, {} as Record<string, any>)
                  }}
                  className="h-[220px]"
                >
                  <BarChart
                    accessibilityLayer
                    data={chartData.commonWords.map((item, index) => ({
                      ...item,
                      fill: COLORS[index % COLORS.length]
                    }))}
                    layout="vertical"
                    margin={{
                      left: 0,
                      top: 2,
                      bottom: 2,
                    }}
                    barSize={8}
                    barGap={1}
                  >
                    <YAxis
                      dataKey="word"
                      type="category"
                      tickLine={false}
                      tickMargin={10}
                      axisLine={false}
                      tickFormatter={(value) => value}
                    />
                    <XAxis dataKey="count" type="number" hide />
                    <ClientOnly><RechartsTooltip
                      cursor={false}
                      content={() => <ChartTooltipContent hideLabel />}
                    /></ClientOnly>
                    <Bar 
                      dataKey="count" 
                      layout="vertical" 
                      radius={5}
                      onClick={handleWordClick}
                      cursor="pointer"
                    />
                  </BarChart>
                </ChartContainer>
              </CardContent>
              <CardFooter className="flex-col items-start gap-2 text-sm">
                <div className="flex gap-2 font-medium leading-none">
                  Top word: {chartData.commonWords[0]?.word || "none"}
                  <TrendingUp className="h-4 w-4" />
                </div>
                <div className="leading-none text-muted-foreground">
                  Showing most common words across all emoji names
                </div>
              </CardFooter>
            </Card>

            {/* Common Words Table */}
            <Card className="md:col-span-1 lg:col-span-2 flex flex-col">
              <CardHeader>
                <CardTitle>Word Frequency Table</CardTitle>
                <CardDescription>Search and explore emoji word usage</CardDescription>
              </CardHeader>
              <CardContent>
                <div className="flex flex-col gap-4">
                  <div className="relative">
                    <input 
                      type="text" 
                      placeholder="Search for words..." 
                      className="w-full px-3 py-2 border rounded-md border-input bg-background text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring" 
                      value={selectedWord || ''}
                      onChange={(e) => {
                        const value = e.target.value;
                        setSelectedWord(value || null);
                        if (value) {
                          const matchingEmojis = emojiData.filter(emoji => 
                            !emoji.is_alias && emoji.name && emoji.name.toLowerCase().includes(value.toLowerCase())
                          ).sort((a, b) => (b.created || 0) - (a.created || 0));
                          setEmojisWithWord(matchingEmojis);
                        } else {
                          setEmojisWithWord([]);
                        }
                      }}
                    />
                    {selectedWord && (
                      <button 
                        className="absolute right-2 top-2 text-muted-foreground hover:text-foreground"
                        onClick={() => {
                          setSelectedWord(null);
                          setEmojisWithWord([]);
                        }}
                      >
                        ×
                      </button>
                    )}
                  </div>
                  <div className="border rounded-md overflow-hidden">
                    <div className="grid grid-cols-3 font-medium bg-muted px-3 py-2 text-xs">
                      <div>Word</div>
                      <div className="text-right">Count</div>
                      <div className="text-right">% of Total</div>
                    </div>
                    <ScrollArea className="h-[180px]">
                      {(() => {
                        // Filter and sort words based on selectedWord or search
                        const allWords = chartData.commonWords || [];
                        const filteredWords = selectedWord
                          ? allWords.filter((item: any) => item.word.toLowerCase().includes(selectedWord.toLowerCase()))
                          : allWords;
                        // Total emojis is the sum of all counts in commonWords (or emojiData.length if you want total unique emojis)
                        const totalEmojis = emojiData ? emojiData.length : filteredWords.reduce((acc: number, item: any) => acc + (item.count || 0), 0);
                        return filteredWords.map((item: any, index: number) => {
                          const percentage = totalEmojis > 0 ? (((item.count as number) / totalEmojis) * 100).toFixed(1) : '0.0';
                          return (
                            <div 
                              key={item.word} 
                              className={`grid grid-cols-3 px-3 py-2 text-sm border-t border-border ${selectedWord === item.word ? 'bg-accent' : 'hover:bg-accent/50'}`}
                              onClick={() => handleWordClick(item)}
                              style={{ cursor: 'pointer' }}
                            >
                              <div>{item.word}</div>
                              <div className="text-right">{item.count}</div>
                              <div className="text-right">{percentage}%</div>
                            </div>
                          );
                        });
                      })()}
                    </ScrollArea>
                  </div>
                  {selectedWord && emojisWithWord.length > 0 && (
                    <div className="mt-2">
                      <div className="text-sm font-medium mb-2">{emojisWithWord.length} matching emojis</div>
                      <div className="flex flex-wrap gap-2">
                        {emojisWithWord.slice(0, 8).map((emoji) => (
                          <div 
                            key={emoji.name} 
                            className="w-8 h-8 flex items-center justify-center border rounded cursor-pointer hover:bg-accent"
                            onClick={() => handleEmojiClick(emoji)}
                          >
                            <img 
                              src={emoji.url} 
                              alt={emoji.name} 
                              className="max-w-full max-h-full object-contain"
                            />
                          </div>
                        ))}
                        {emojisWithWord.length > 8 && (
                          <div 
                            key="more-emoji"
                            className="w-8 h-8 flex items-center justify-center border rounded cursor-pointer hover:bg-accent text-xs"
                            onClick={() => {
                              setShowWordEmojiDialog(true);
                            }}
                          >
                            +{emojisWithWord.length - 8}
                          </div>
                        )}
                      </div>
                    </div>
                  )}
                </div>
              </div>
            </CardContent>
          </Card>
        </div>
      )}
    </>
  )}
</>
)
